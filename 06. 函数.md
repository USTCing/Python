# 05. 函数



将经常使用的代码模块定义为函数，避免重复，在使用的时候进行调用提高代码利用率。给函数进行命名时，尽量做到见名知意。

## 1. 定义函数

> 参考文献：[定义函数](https://docs.python.org/zh-cn/3.8/tutorial/controlflow.html#defining-functions)

关键字 [`def`](https://docs.python.org/zh-cn/3.8/reference/compound_stmts.html#def) 引入一个函数定义。它必须后跟函数名称和带括号的形式参数列表。构成函数体的语句从下一行开始，并且必须缩进。在下面的`fib()`函数中，n是形参，其默认值为10，在实际调用函数的过程中，如`fib(20)`，这里的20就是实参。而函数定义后面的紧跟的所有相同缩进的内容，都是该函数的函数体。紧跟`def`的`fib`就是函数名。

我们可以创建一个输出任意范围内 Fibonacci 数列的函数:

```python
def fib(n=10):    # def是关键字（define），fib是函数名，n是形参，其默认值为10
    """打印一个直到n的斐波那契序列。"""	# 文档信息/注释，使用help(fib)会显示该行信息
    a, b = 0, 1			# 从这往下是函数体，函数的执行部分
    while a < n:		# 函数体需要保持缩进的一致性
        print(a, end=' ')
        a, b = b, a+b
    print()
```

函数的 *执行* 会引入一个用于函数局部变量的新符号表。 更确切地说，函数中所有的变量赋值都将存储在局部符号表中；而变量引用会首先在局部符号表中查找，然后是外层函数的局部符号表，再然后是全局符号表，最后是内置名称的符号表。 因此，全局变量和外层函数的变量不能在函数内部直接赋值（除非是在 [`global`](https://docs.python.org/zh-cn/3.8/reference/simple_stmts.html#global) 语句中定义的全局变量，或者是在 [`nonlocal`](https://docs.python.org/zh-cn/3.8/reference/simple_stmts.html#nonlocal) 语句中定义的外层函数的变量），尽管它们可以被引用。

当你定义了一个变量a，然后在函数中引用了该变量，当执行该包含该函数的`.py`文件时，系统会提示该变量未定义，就是上面的原因。即使你没有定义函数，只是一个简单的脚本中引用该变量，也依然会报错。你需要把这个变量写到脚本里才可以。

### 1.1 函数的返回值

写一个返回斐波那契数列的列表（而不是把它打印出来）的函数，非常简单：

```python
def fib2(n):  # return Fibonacci series up to n
    """Return a list containing the Fibonacci series up to n."""
    result = []
    a, b = 0, 1
    while a < n:
        result.append(a)    # see below
        a, b = b, a+b
    return result
```

上面两个的差别是什么呢？注意看他们的**返回类型**：

```python
>>> a = fib(20)		# 实际执行的还是print，是没有类型的，所以也无法对a进行其他操作
0 1 1 2 3 5 8 13  
>>> type(a)
NoneType
>>> b = fib2(10)	# 这里相当于利用函数对b进行赋值，返回的是None，即：一个空行
>>> b				# b是列表，可以进行列表的相关操作
[0, 1, 1, 2, 3, 5, 8]
>>> type(b)			# 看函数fib2()的代码可知，return返回的是类型为列表的result
list
>>> c = fib()		# 使用默认值n=10
0 1 1 2 3 5 8
```

函数可以返回很多类型的值，对这些值我们可以采用相应的方式进行处理。因此，根据目的指定返回值的类型是很重要的。

### 1.2 用模块管理函数

当在不同的.py文件中定义了同名的函数，如fib，为了避免混淆及覆盖等问题，一种方式就是使用模块管理函数，比如我们分别在A.py和B.py中定义了同名的fib函数，可以这么处理：

```python
import A import fib as f1
import B import fib as f2		# as后面如果重名会被覆盖（如将f2改为f1），但不会报错
```

当文件的名字非常长的时候，如add_sub.py，且里面有好几个函数（如def x 和 def y），

```python
def add(x,y):
    return x+y
def sub(x,y):
    return x-y
```

调用的时候可以这么操作：

```python
import add_sub as A
A.add(1,2)
A.sub(5,2)
```



## 2. 函数的参数

在Python中定义函数，有5种参数：必选参数、默认参数、可变参数和关键字参数和命名关键字参数，这5种参数可以一起使用，或者只用其中某些，但参数定义的顺序必须是：必选参数、默认参数、可变参数、命名关键字参数和关键字参数。

### 2.1 默认参数

 当参数具有默认值时，可以不用给对应参数赋值，该参数变为可选参数，但其他参数都必须赋值。**`默认值只会执行一次`**。这条规则在默认值为可变对象（列表、字典以及大多数类实例）时很重要。比如，下面的函数会存储在后续调用中传递给它的参数：

```python
def f(a, L=[]):		# L的默认值是一个空列表，赋值时可以不用给出
    L.append(a)		# a,L均为参数的关键字
    return L

print(f(1))			# 在调用时，如果没有使用关键字，则按参数位置依次赋值
print(f(2))			# 此时1，2均传入到位置为1的a参数，而L本身是空列表，执行append()后值变了
print(f(2,[]))		# 这里看似把L设为空的列表了，实际没有，只是给L传递了一个值
print(f(3))			# L本身作为变量，它的值已经发生变化了，此时为[1, 2]
# 这将打印出
[1]
[1, 2]
[2]
[1, 2, 3]
```

默认参数`L`也是一个变量，它指向对象`[]`，每次调用该函数，如果改变了`L`的内容，则下次调用时，默认参数的内容就变了，不再是函数定义时的`[]`了。如果你不想要在后续调用之间共享默认值，你可以这样写这个函数：

```python
def f(a, L=None):
    if L is None:
        L = []
    L.append(a)
    return L
```



### 2.2 关键字参数

也可以使用形如 kwarg=value 的 关键字参数 来调用函数，其中kwarg应该是key words arguments的缩写。关键字参数允许你传入0个或任意个含参数名的参数，这些关键字参数在函数内部自动组装为一个dict，而字典的构成是{键key: 值value}对应的，参数传递时关键字就是字典里的key，key匹配后对其对应的value（即参数）赋值。这种字典格式，也是后面解包的基础。例如下面的函数：

```python
def stu(name, age=7, gender='男'): # 接收一个必需的参数（name）和两个可选的参数（age, gender）
    print('%s,%s, 已经%d岁了' % (name, gender, age), end='')
# 注意，age这里我们通过%d限定了输出时int型，给的数据类型不匹配会报错

>>> stu('Bob',age=8)	# 接收一个位置参数和一个关键字参数，字典格式：{'name':'Bob','age'=8}
Bob,男, 已经8岁了

>>> stu('Rose',8,'女')	# 在没有给出任何一个关键词时，所有参数均为位置参数
Rose,女, 已经8岁了
```

简单小结一下，上面函数一共有三个参数：name, age=7, gender='男'。其中有默认值的参数就变成了可选参数（age=7, gender='男'），而没有默认值的参数就是必选参数（name）。当没有通过关键字（name, age，gender）赋值时，所有参数均为位置参数。如果只给出了其中的某几个关键字，则其他参数会根据其所处的位置，依据位置从左向右进行赋值。如果要限制关键字参数的名字，例如，只接收gender和hobby作为关键字参数。这种方式定义的函数如下：

```python
# 此时name，age依然是位置参数，也可以通过关键词进行参数传入
# 但gender,hobby不再是位置参数，只能通过关键词进行参数传入
def stu(name, age, *, gender, hobby):
    print(name, age, gender, hobby)
    
>>> stu(1,2, city=3, job=4)
stu() got an unexpected keyword argument 'city'
>>> stu(1,2, gender=3, hobby=4)
1 2 3 4
```

命名关键字参数必须传入参数名（gender, hobby），这和位置参数（name, age）不同。如果没有传入参数名，调用将报错：

```python
>>> stu(1,2,3,4)
stu() takes 2 positional arguments but 4 were given
```

由于调用时缺少参数名gender和hobby，Python解释器把这4个参数均视为位置参数，但stu()函数仅接受2个位置参数。命名关键字参数可以有缺省值，从而简化调用，由于命名关键字参数*gender*具有默认值，调用时，可不传入*gender*参数：

```python
def stu(name, age, *, gender='boy', hobby):
    print(name, age, gender, hobby)
    
>>> stu(1,2, hobby=4)
1 2 boy 4
```

使用命名关键字参数时，要特别注意，如果没有可变参数，就必须加一个`*`作为特殊分隔符。如果缺少`*`，Python解释器将无法识别位置参数和命名关键字参数：

```python
def stu(name, age, gender, hobby):	# 所有参数均被视为位置参数
    print(name, age, gender, hobby)
```



### 2.3 可变参数

在Python中，函数的参数可以有默认值，也支持使用可变参数。可变参数允许你传入0个或任意个参数，这些可变参数在函数调用时自动组装为一个元组tuple。正常情况如果我们定义一个简单的加法函数，比如：

```python
>>> add = lambda x,y:x+y		# 使用lambda函数创建简单函数的时候非常方便
>>> add(1,2)
3
>>> add(1,2) + add(3,4)
10
```

但如果我们需要执行多个数字的加法，就会使得函数的调用异常麻烦，这时候我们就需要使用可变参数，如：

```python
def add1(*args):
    ans = 0
    for x in args:
        ans += x
    return ans
>>> print(add1(1, 3, 5, 7, 9))
25

# 也可以直接向函数传递列表
# 当函数会对列表进行修改，但不希望直接对原列表进行修改时，可以使用副本的方式
# 即 def add2(A[:])，这个我们在for循环中的2.1 for...in部分讲过类似的情况
def add2(A):
    ans = 0
    for i in A:
        ans += i
    return ans
>>> add2([1,2,3])
6
>>> add1([1,2,3])	# 在上面两个函数中，ans都是int型，不能和list相加，但后一个做了拆包
TypeError: unsupported operand type(s) for +=: 'int' and 'list'
```

**`解包参数列表`**：当参数已经在列表或元组中，但函数需要调用的位置参数需要单个参数时，可以使用 `*` 操作符从列表或元组中解包参数：

```python
>>> num = [1, 2, 3]
>>> add(*num)	# 把list或tuple的元素变成可变参数传进去
6
```

同样的=，字典可使用 `**` 操作符 来提供关键字参数:

```python
def p(name, age, gender):
    print('name:', name, 'age:', age, 'gender:', gender)

>>> s = {'name':'Bob', 'age':18, 'gender':'boy'}
>>> p(**s)	# p在使用**解包后通过关键词传入参数
name: Bob age: 18 gender: boy
```

一般来说，这些 可变参数将在形式参数列表的末尾，因为它们收集传递给函数的所有 ***剩余*** 输入参数。出现在 `*args` 参数之后的任何形式参数都是 ‘仅限关键字参数’，也就是说它们只能作为关键字参数而不能是位置参数。



### 2.4 特殊参数：

默认情况下，函数的参数传递形式可以是位置参数或是显式的关键字参数。 为了确保可读性和运行效率，***限制允许的参数传递形式***是有意义的，这样开发者只需查看函数定义即可确定参数项是仅按位置、按位置也按关键字，还是仅按关键字传递。

```
def f(pos1, pos2, /, pos_or_kwd, *, kwd1, kwd2):
      -----------    ----------     ----------
        |             |                  |
        |        Positional or keyword   |
        |                                - Keyword only
         -- Positional only
```

在这里 `/` 和 `*` 是可选的。 如果使用这些符号，则表明可以通过何种形参将参数值传递给函数：仅限位置、位置或关键字，以及仅限关键字。 关键字形参也被称为命名形参。如果函数定义中未使用 `/` 和 `*`，则参数可以按位置或按关键字传递给函数。

```python
def p(name, age):		# 位置参数，关键字均可传入
    print('name:', name, 'age:')
    
def p(name, age,/):		# 仅限位置参数
    print('name:', name, 'age:')

def p(*, name, age):	# 仅限关键字参数
    print('name:', name, 'age:')
    
def p(name,/, age, *, gender):	# name仅限位置参数,age为位置或关键字参数，gender仅为关键字参数
    print('name:', name, 'age:', age, 'gender:', gender) 
```

注意写法不要出错，比如第四个的`/`前后都有逗号。限定参数测传入可以避免一些潜在的冲突：

```python
# 任何调用都不可能让它返回 True，因为关键字 'name' 将总是绑定到第一个形参。
def foo(name, **kwds):	
    return 'name' in kwds
>>> foo(1, **{'name': 2})
TypeError: foo() got multiple values for argument 'name'

# 但使用 / (仅限位置参数) 就可能做到，因为使name仅作为位置参数，
# 而后面的 'name' 将作为关键字参数的关键字名称传入给**kwds:
def foo(name, /, **kwds):
    return 'name' in kwds
>>> foo(10, **{'name': 2})	# name获得位置为1的参数10，而字符串'name'传给**kwds
True
```

这样做还有其他考虑，初学阶段想要了解参见：[函数示例](https://docs.python.org/zh-cn/3.8/tutorial/controlflow.html#function-examples)



## 3. if \_\__name \_\_ ==  '\_\_main\_\__\' 

Python解释器在导入模块时，会将模块中没有缩进的代码全部执行一遍（模块就是一个独立的Python文件，比如函数）。\_\_name\_\_是Python中一个隐含的变量它代表了模块的名字，只有被Python解释器直接执行的模块的名字才是\_\_main\_\_。比如创建了两个文件，A.py 和B.py，下面两个语句都是查看A的名字：

```python
# 当在A.py 中运行
>>> print(__name__)
__main__
# 但如果是在B.py中运行如下代码：
>>> print(A.__name__)
A
```

当哪个模块被直接执行时，该模块”\_\_name \_\_“ 的值就是“\_\_main\_\_”，当被导入另一模块时，“\_\_name \_\_”的值就是模块的真实名称。因此\_\_name \_\_  == '\_\_main\_\_' ，就表示运行的文件是当前文件，所以，可以在if \_\_name \_\_ ==  '\_\_main\_\_':条件下写入测试代码，如此可以避免测试代码在模块被导入后执行。

那么，如何利用\_\__name \_\_ 属性避免这些测试代码在模块被导入后执行，看下面的例子。模块A、B表示**两个**脚本文件A.py 和B.py。

```python
# 模块A
print('A: 允许被执行')    # 输出A1
A = 'A: 不想被执行'
print(A)				# 输出A2

# B模块
from A import A			# 此时就执行了A，输出A1和A2
B = '这是B模块'
print(B)
```

只执行B模块的结果为（A已经被导入了）：

```python
A: 允许被执行
A: 不想被执行
这是B模块
```

利用\_\__name \_\_ 属性避免这些测试代码在模块被导入后执行，需要作如下处理：

```python
# 模块A
print('A: 允许被执行')				# 输出A1
A = 'A: 不想被执行'

if __name__ == '__main__':			# 仅当运行的文件为A时，才会输出A2，被调用时，只会输出A1
    print(A)	 					# 输出A2
```

这时，只执行B模块的结果为：

```python
A: 允许被执行
这是B模块
```

简单总结下，在if \_\_name \_\_ ==  '\_\_main\_\_'以上的代码会被其他模块调用，其下面的只有在运行本模块时才会调用。因为在一个模块中可能有很多其他模块可以调用的函数，通过调用提高代码利用率，而对于一个单独模块而言，其内往往有多个函数，在if \_\_name \_\_ ==  '\_\_main\_\_'以下，通过不同函数的组合调用以及其他操作能够实现特定的目的，而这个目的在其他模块调用的时候是不可见的。通过这种方式，既提高了代码的利用率，避免重复造轮子的情况，又保护了特定代码模块的安全性。此外，也避免了其他模块在调用时获得过多的输出，以及变量覆盖等问题（比如存在global定义的全局变量）。

## 4.  函数模块

模块是扩展名为`.py`的文件，Python有很强大的库，这些库就是一个个的`.py`文件，通过import导入，即可使用其内部定义的函数。

下面是一些典型的模块导入操作：

```python
import A				# 使用模块A内部的函数a时，可以用：A.a调用
from A import B			# 导入特定的函数
from A import *			# 导入所有的函数
from A import B as b	# 给函数指定别名
import A as a			# 给模块指定别名
```

使用help(A)，可以查看模块或函数的注释信息（如果有的话）。

## 5. 函数编写指南  

#### 为了提高程序的可读性，应尽量遵守以下规则：

* 应给函数指定描述性名称，做到见名知意，且只在其中使用小写字母和下划线；
* 函数最好包含简要地阐述其功能的注释，该注释应紧跟在函数定义后面，并采用文档字符串格式；
* 给形参指定默认值时，等号两边不要有空格；
* 如果程序或模块包含多个函数，可使用两个空行将相邻的函数分开，这样将更容易知道前一个函数在什么地方结束，下一个函数从什么地方开始；
* 所有的import语句都应放在文件开头，唯一例外的情形是，在文件开头使用了注释来描述整个程序；

#### 之前介绍过变量的命名规则，这里再次补充一遍：

- 变量名由字母、数字和下划线构成，不能以数字开头，不能包含空格，但可使用下划线来分隔其中的单词  ；
- 大小写敏感（大写的`A`和小写的`a`是两个不同的变量）；
- 不要跟关键字（有特殊含义的单词）和系统保留字（如函数、模块等的名字）冲突；
- 变量名应既简短又具有描述性。例如， name比n好， student_name比s_n好 ；慎用小写字母l和大写字母O，因为它们可能被人错看成数字1和0；如果建立的变量包含多个元素，考虑使用复数，比如students等；

* 以一致的规则为你的类和函数命名，变量或函数命名单词用小写，用下划线连接，如：stu_name；
* 类的命名用`UpperCamelCase`法，每部分单词的首字母大写，如：StuName；
* 始终应使用 self 来命名第一个方法参数，受保护的实例属性用单个下划线开头，私有的实例属性用两个下划线开头。