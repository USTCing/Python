# 数据类型：数字，字符串，列表



官方手册是内容最全，也是解释最到位的学习资料。详参：[Python 教程](https://docs.python.org/zh-cn/3.8/tutorial/index.html)，本文中很多内容来自于官方文档。

| 文本类型： | 标识符                     | 备注         |
| ---------- | -------------------------- | ------------ |
| 数值类型   | int, float, complex        |              |
| 序列类型   | list: [], tuple: (), range | 元组不可修改 |
| 映射类型   | dict: {}                   |              |
| 集合类型   | set, frozenset             | 元素不重复   |
| 布尔类型   | bool                       |              |
| 二进制类型 | bytes, array, memory，view |              |

> 这里复制的，可能有误，后面会再改

不同类型的变量适合存储不同类型的信息，在程序中可以随时修改变量的值，而Python将始终记录变量的最新值。  

## 1. 数字：

整数（比如 2、3 ）的类型是 [`int`](https://docs.python.org/zh-cn/3.8/library/functions.html#int)，有小数部分的（比如 1.35）的类型是 [`float`](https://docs.python.org/zh-cn/3.8/library/functions.html#float)。包含多种混合类型运算数的运算会把整数转换为浮点数。要从一个复数[`complex`](https://docs.python.org/zh-cn/3.8/library/functions.html#complex) ：*z* 中提取这两个部分，可使用 `z.real` 和 `z.imag`。数字是由数字字面值或内置函数与运算符的结果来创建的。在数字字面值末尾加上 `'j'` 或 `'J'` 会生成虚数（实部为零的复数），你可以将其与整数或浮点数相加来得到具有实部和虚部的复数。

Python 完全支持混合运算：当一个二元算术运算符的操作数有不同数值类型时，"较窄"类型的操作数会拓宽到另一个操作数的类型，其中整数比浮点数窄，浮点数比复数窄。

所有数字类型（复数除外）都支持下列运算，（有关运算优先级，请参阅：[运算符优先级](https://docs.python.org/zh-cn/3.8/reference/expressions.html#operator-summary)）:

| 运算符                                   | 描述                                                         |
| ---------------------------------------- | ------------------------------------------------------------ |
| `pow(x, y)`  `x ** y`                    | *x* 的 *y* 次幂：2**3=8                                      |
| `%` `//`                                 | 模（余数）17 % 3=2，整除（商数）17 // 3=5                    |
| `+` `-` `*` `/`                          | 加，减，乘，除（永远返回浮点数类型）17 / 3  = 5.666666666666667 |
| `+x`   `-x`                              | *x*不变  /  *x* 取反                                         |
| `=` `+=` `-=` `*=` `/=` `%=` `//=` `**=` | 赋值运算符，如： a+=1即为： a = a+1                          |
| `abs(x)`                                 | *x* 的绝对值或大小                                           |
| `int(x)`                                 | 将 *x* 转换为整数，四舍五入                                  |
| `float(x)`                               | 将 *x* 转换为浮点数                                          |
| `complex(re, im)`                        | 一个带有实部 *re* 和虚部 *im* 的复数；*im* 默认为0。         |
| `c.conjugate()`                          | 复数 *c* 的共轭                                              |
| `divmod(x, y)`                           | `(x // y, x % y)`                                            |

**注**：详细参考：[数字类型 --- int, float, complex](https://docs.python.org/zh-cn/3.8/library/stdtypes.html#numeric-types-int-float-complex)

* `x // y` 结果值是一个整数，但结果的类型不一定是 int。 运算结果总是向负无穷的方向舍入: `1//2` 为 `0`, `(-1)//2` 为 `-1`, `1//(-2)` 为 `-1` 而 `(-1)//(-2)` 为 `0`。
* `x % y`不可用于复数。 而应在适当条件下使用 [`abs()`](https://docs.python.org/zh-cn/3.8/library/functions.html#abs) 转换为浮点数。



运算优先级：因为 `**` 比 `-` 有更高的优先级, 所以 `-3**2` 会被解释成 `-(3**2)` ，因此结果是 `-9`. 为了避免这个并且得到结果 `9`, 你可以用这个式子 `(-3)**2`。

在交互模式下，上一次打印出来的表达式被赋值给变量 `_`。这意味着当你把Python用作桌面计算器时，继续计算会相对简单，比如:

```python
>>> tax = 12.5 / 100
>>> price = 100.50
>>> price * tax
12.5625
>>> price + _
113.0625
>>> round(_, 2)
113.06
```

`_`这个变量应该被使用者当作是只读类型。不要向它显式地赋值。你会创建一个和它名字相同独立的本地变量，它会使用魔法行为屏蔽内部变量。

**多重赋值**：如下面代码的第1, 4行。对于a, b = b, a+b而言，是先对等号右边进行从左到右被求值，然后再依次赋值给等号左边。斐波那契数列的计算：

```python
>>> a, b = 0, 1
>>> while a < 10:
>>> 	print(a)
>>> 	a, b = b, a+b
```



## 2. 字符串：



### 2.1 字符串的基本解释

字符串有多种形式，可以使用单引号（`'...'`），双引号（`"..."`）都可以获得同样的结果，唯一的区别是，你不需要在单引号里转义双引号 `"` (但是你必须把单引号转义成 `\'`) ， 反之亦然。

```python
>>> 'I\'m'	# 单引号里面输入单引号需要转义
"I'm"
>>> "I'm"	# 双引号里面输入单引号不需要转义
"I'm"
# 注意：上面的写法只会在交互界面输出，而在脚本中则不会输出（要用print("I'm")）
# 注意中英文括号
```

在交互式解释器中，输出的字符串外面会加上引号， print() 函数会生成可读性更强的输出，即略去两边的引号，并且打印出经过转义的特殊字符，在引号前添加 `r` 可以取消转义：

```python
>>> s = 'First line.\nSecond line.'  # \n 表示换行
>>> s  # 不使用print(), \n 会包含在输出中
'First line.\nSecond line.'
>>> print(s)  # 使用print(), \n 表示换行
First line.
Second line.
>>> print(r'C:\some\name')  # 里面的\n没有被转义
C:\some\name
```

字符串字面值可以跨行连续输入。一种方式是用三重引号：`"""..."""` 或 `'''...'''`。字符串中的回车换行会自动包含到字符串中，如果不想包含，在行尾添加一个 `\` 即可。如下例:

```python
>>> print("""\		# 第一行的换行取消了，但末尾多了两个换行？
>>> 11
>>>       1
>>>       2
>>> """)
11
      1
      2


```



### 2.2 转义符：

| 表示符         | 描述               |
| :------------- | :----------------- |
| `\n`           | 换行               |
| `\t`           | 一个制表位         |
| `\r`           | 回车               |
| `\r\n`         | 回车 + 换行        |
| `\v` 或 `\x0b` | 行制表符           |
| `\f` 或 `\x0c` | 换表单             |
| `\x1c`         | 文件分隔符         |
| `\x1d`         | 组分隔符           |
| `\x1e`         | 记录分隔符         |
| `\x85`         | 下一行 (C1 控制码) |
| `\u2028`       | 行分隔符           |
| `\u2029`       | 段分隔符           |

```python
>>> print('你好，\t小明！\n你好，\t小莉！')
你好，	小明！
你好，	小莉！
```



### 2.3 字符串的拼接

可以用 `+` 进行连接（粘到一起），也可以用 `*` 进行重复，相邻的两个或多个 *字符串字面值* （引号引起来的字符）将会自动连接到一起。

```python
>>> 3*'a'+'b'+'c'*2
'aaabcc'
>>> 'Py' 'thon'
'Python'
# 只能对两个字面值这样操作，变量或表达式不行：('a' * 3) 'b' 报错
# 可以使用加号拼接：('a' * 3) + 'b'
```

把很长的字符串拆开分别输入的时候尤其有用:

```python
>>> text = ('Put several strings within parentheses '
...         'to have them joined together.')
>>> text
'Put several strings within parentheses to have them joined together.'
```

字符串是可以被 `索引` （下标访问）、`切片`的，第一个字符索引是 0。切片的索引有默认值；省略开始索引时默认为0，省略结束索引时默认为到字符串的结束。索引超出范围会报错，切片超出索引范围会被自动处理为到字符串的结束位置。

```python
>>> a = 'Python'
>>> a[0]
'P'
>>> a[0:2],a[-2:100]	# 切片的开始总是被包括在结果中，而结束不被包括。100被自动处理了
('Py', 'on')
>>> a[::-1] 		# 反着输出
'nohtyP'
>>> a[:2]*2 + a[-2:]		# 索引得到单个字符，切片得到子字符串，可以使用字符串的拼接等
'PyPyon'
```

内建函数 [len()](https://docs.python.org/zh-cn/3.8/library/functions.html#len) 返回一个字符串的长度:

```python
>>> s = 'supercalifragilisticexpialidocious'
>>> len(s)
34
```



### 2.4 字符串的方法

为简便起见，输出结果用等号连接。

| 语法                              | 含义                                             | 例子                                    |
| --------------------------------- | ------------------------------------------------ | --------------------------------------- |
| `str.capitalize()`                | 返回原字符串的副本，其首个字符大写，其余为小写。 | ’BOB‘.capitalize() = Bob                |
| `str1.upper()` <br/>`str.lower()` | 全大写<br/>全小写                                | 'Abc'.upper()='ABC'<br/>'ABC'.lower=abc |
| `str.casefold()`                  | 把字符串转换为小写，比`str.low()`更彻底          | 德语小写字母 'ß' 相当于 "ss"。 由于它已经是小写了，lower() 不会对 'ß' 做任何改变；而 casefold() 则会将其转换为 "ss"。 |
| `str.find()`                      | 从字符串中查找子串所在位置                       | 'ABCDEc'.find('c') = 5                  |
| `str.ljust()`<br/>`str.rjust()`<br/>`str.center()` | 将字符串以指定的宽度左/右/居中对齐，并在两侧填充指定的字符 | 'A'.center(10,'-') =  '----A-----' |
| `str.startswith()`<br/>`str.endswith()` | 检查字符串是否以指定的字符串开头/结尾 | 'ABC'.startswith('a') = False |
| `str.replace(old, new,count)` |返回字符串的副本，其中出现的所有子字符串 *old* 都将被替换为 *new*。 如果给出了可选参数 *count*，则只替换前 *count* 次出现。|'a-a-a-a-a'.replace('a','A',2)= 'A-A-a-a-a'|
| ``str.``partition(*sep*)` |在 *sep* 首次出现的位置拆分字符串，返回一个 3 元组。 如果分隔符未找到，则返回的 3 元组中包含字符本身以及两个空字符串。|'aabcc'.partition('b') =  ('aa', 'b', 'cc')|
| `str.``encode(*encoding="utf-8"*, *errors="strict"*)` |返回原字符串编码为字节串对象的版本。 默认编码为 `'utf-8'`。 可以给出 *errors* 来设置不同的错误处理方案。 *errors* 的默认值为 `'strict'`，表示编码错误会引发UnicodeError。 其他可用的值为 `'ignore'`||
| `str.isdigit()`<br/>`str.isalpha()`<br/>`str.isalnum()` |检查字符串是否由：数字/字母/数字和字母 构成，返回布尔值|'123'.isdigit() = True|
| `str.lstrip()`<br/>`str.rstrip()` |移除其中的前导/末尾字符|'xx123xx'.lstrip('x')= '123xx'|
| `str.strip([chars])` |实际上 *chars* 参数并非指定单个前缀或后缀；而是会移除参数值的所有组合|'www,exampl,com'.strip('cmowz,')  = 'example'|
| `str.split(sep=None, maxsplit=-1)` |使用 *sep* 作为分隔字符串，最多会有 `maxsplit+1` 个元素，默认值-1进行所有可能的拆分|'1x2x3x4'.split('x',2)= ['1', '2', '3x4']|

字符串还有几十种其他操作，这里不一一介绍了，详参：[字符串的方法](https://docs.python.org/zh-cn/3.8/library/stdtypes.html#string-methods)。



## 3. 列表 [] : list 

列表(list)，是一种结构化的、非标量类型，它是值的有序序列，每个值都可以通过索引进行标识，一个列表可以包含不同类型的元素。和字符串（以及各种内置的 sequence 类型）一样，列表也支持索引和切片，与字符串一样列表也支持拼接操作，但与 [immutable](https://docs.python.org/zh-cn/3.8/glossary.html#term-immutable) 的字符串不同， 列表是一个 [mutable](https://docs.python.org/zh-cn/3.8/glossary.html#term-mutable) 类型，即其内容可以改变。可以在列表末尾通过 `append()` 方法来添加新元素，利用切片对其进行赋值时，令其等于`[]`意味着删除。若是索引，则相当于令该位置的元素等于一个空的列表。

```python
>>> a,b = list(range(1, 6)),list(range(5, 7))
>>> a+b
[1, 2, 3, 4, 5, 5, 6]
>>> a[0] 				# Python中，索引（即下标）是从0开始的：a[0]=1，a[-1]=6
>>> a[0:2]=[]			# 切片操作：将a中的1,2删除，此时a=[3, 4, 5]
>>> a[:] = [],1,'aa'	# 此时a=[[], 1, 'aa']
>>>a[:] = []			# 把列表整个清空: []
>>> stu = ['bob','lili','tom']	# 结合上面字符串的方法使用
>>> print('The best student is: ' + stu[0].title()+'.')	# 列表的索引+字符串的拼接
# 如果stu里面的内容类型不是str会出错
The best student is: Bob.
```

在对列进行操作时，要注意引用和复制的区别：

```
>>> A = [1,2,3]
>>> B = A		# 这时，是将A赋给了B，A，B指向了同一个列表，AB的所有变动都会出现在彼此上
>>> A.append(4)
>>> B.append(5)	# 并不是A:[1, 2, 3, 4]，B:[1, 2, 3, 5]
>>> print(A,B,sep='\n')
[1, 2, 3, 4, 5]
[1, 2, 3, 4, 5]
# 避免这种问题的方法是为B赋值A的副本,将B = A改为如下代码后，请自行尝试上述操作
>>> B = A[:]
```



### 3.1 列表对象的方法

Python中的小数点`.`可以理解为一个属性操作符，比如*A.b*，就是对对象*A*执行*b*方法的操作。

> 参考文献：[数据结构](https://docs.python.org/zh-cn/3.8/tutorial/datastructures.html#data-structures)

| **方法**                          | **描述**                                                     |
| --------------------------------- | ------------------------------------------------------------ |
| .append()                         | 在列表的末尾添加一个元素。相当于 `a[len(a):] = [x]`          |
| .clear()                          | 移除列表中的所有元素。等价于`del a[:]`                       |
| .copy()                           | 返回列表的一个浅拷贝，等价于 `a[:]`                          |
| .count(x)                         | 返回元素 *x* 在列表中出现的次数                              |
| .extend()                         | 将列表元素（或任何可迭代的元素）添加到当前列表的末尾，`a[len(a):] = iterable` |
| .index(x[, start[, end]])         | 返回具有指定值的第一个元素的索引,可选参数 *start* 和 *end* 是切片符号，用于将搜索限制为列表的特定子序列。返回的索引是相对于整个序列的开始计算的，而不以*start* 参数为起始点算的。只给出*start*而没有*end*时，end默认为列表结尾。 |
| .insert(i, x)                     | 在指定位置 i 添加元素 x                                      |
| .pop([i])                         | 删除列表中给定位置 i 的元素并返回它，默认是最后一个          |
| .remove(x)                        | 移除列表中第一个值为 *x* 的元素，如果没有这样的元素，则抛出异常 |
| .reverse()                        | 翻转列表中的元素，负负得正，再次翻转复原，只翻转不排序。     |
| .sort(*, key=None, reverse=False) | *key* 指定带有单个参数的函数，用于从 *iterable* 的每个元素中提取用于比较的键 (例如 `key=str.lower`)。 默认值为 `None` (直接比较元素)。*reverse* 为一个布尔值。 如果设为 `True`，则每个列表元素将按反向顺序比较进行排序 |
| `del` 语句                        | 从列表中移除切片，或者清空整个列表del a[:]，也可以删除整个变量del a |

>  注：方法签名中 *i* 两边的方括号表示这个参数是可选的，而不是要你输入方括号。如上面的`.pop([i])` 和 `.index(x[, start[, end]])`，比如*.index(x, start)*，这时*[, end]*被省略了，执行的是*.index(x[, start])*，其中的方括号是不需要输入的，你会在 Python 参考库中经常看到这种表示方法。

这些方法的使用基本和上面字符串方法的使用大同小异，不展开做过多举例。上表中的一些方法，如： `insert` ，`remove` 或者 `sort` 方法，只修改对象，但并不打印出返回值——它们返回默认值 `None` ，在交互界面就是一个空行。

确定每个用法的适用性很重要，比如有时候，你要将元素从列表中删除，并接着使用它的值。你可能要将用户从活跃成员列表中删除，并将其加入到非活跃成员列表中，这时候使用`pop()`  是很合适的。而有时候只需要知道删除的元素名，不想通过索引进行删除，则使用`remove()`是很方便的，尤其是跟列表搭配使用时。甚至有时候可以先对列表进行排序`sort()`，再根据排序结果进行其他操作，这种组合用法也能大大提高效率。

### 3.2 列表推导式

[列表推导式](https://docs.python.org/zh-cn/3.8/tutorial/datastructures.html#list-comprehensions)提供了一个更简单的创建列表的方法。常见的用法是把某种操作应用于序列或可迭代对象的每个元素上，然后使用其结果来创建列表，或者通过满足某些特定条件元素来创建子序列。

假设我们想创建一个平方列表，如：

```python
>>> squares = []
>>> for x in range(10):		# 每次循环从range(10)中依次取一个值赋给变量x
...     squares.append(x**2)	# x也可以是其他名称，但前后必须保持一致
```

注意，这将创建（或覆盖）一个名为 `x` 的变量，该变量在循环结束后仍然存在。下述方法可以无副作用地计算平方列表，即不会创建（或覆盖）名为 `x` 的变量。

```python
squares = list(map(lambda x: x**2, range(10)))
# 等价于
squares = [x**2 for x in range(10)]
```

列表推导式的结构是由一对方括号所包含的以下内容：一个表达式，后面跟一个 `for` 子句，然后是零个或多个 `for` 或 `if` 子句。 其结果将是一个**新列表**，由对表达式依据后面的 `for` 和 `if` 子句的内容进行求值计算而得出。

`for`是循环遍历，`if`是筛选。

```python
>>> [(x, y) for x in [1,2,3] for y in [3,1,4] if x != y]
[(1, 3), (1, 4), (2, 3), (2, 1), (2, 4), (3, 1), (3, 4)]
# 将两个列表中不相等的元素组合起来，它等价于
>>> combs = []
>>> for x in [1,2,3]:
		for y in [3,1,4]:
			if x != y:
				combs.append((x, y))
>>> combs	# 上面两个代码片段中， for 和 if 的顺序是相同的。
[(1, 3), (1, 4), (2, 3), (2, 1), (2, 4), (3, 1), (3, 4)]
```

列表中如果含有字符串或其他元素，还可以直接调用对应的方法，如：

```python
>>> fruit = ['  banana', '  berry ', 'apple  ']
>>> [f.strip() for f in freshfruit]		# 使用.strip()，删除空格
['banana', 'berry', 'apple']
```

使用带有两个“for”的列表元素平展列表：

```python
>>> vec = [[1,2,3], [4,5,6], [7,8,9]]
>>> [num for elem in vec for num in elem]
[1, 2, 3, 4, 5, 6, 7, 8, 9]
```

列表推导式可以使用复杂的表达式和嵌套函数：

```python
>>> from math import pi
>>> [str(round(pi, i)) for i in range(1, 6)]
['3.1', '3.14', '3.142', '3.1416', '3.14159']
```



### 3.3 嵌套的列表推导式

列表推导式中的初始表达式可以是任何表达式，包括另一个列表推导式。即一个表达式里面还有一个表达式：

```python
>>> matrix = [
		[1, 2, 3, 4],		# 下面的嵌套推导式，先将matrix分开为三个列表
		[5, 6, 7, 8],		# 并赋值给row,row获得一行
		[9, 10, 11, 12],	# 再分别取下标（取列），构成新的列表
	]
>>> [[row[i] for row in matrix] for i in range(4)]	# 注意，for前面有个方括号
[[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]
# 先执行第一个方括号，使row获得matrix的三个列表（取行），然后利用range获得row的下标（取列）
# 分别将row三个列表的第1-4个元素重新组成一个新的列表
# 嵌套的列表推导式是基于跟随其后的 for 进行求值的，所以这个例子等价于:
>>> A = []
>>> for i in range(4):
...     A.append([row[i] for row in matrix])
```



### 3.4 lambda函数

常和列表搭等配使用的`lambda `为匿名内联函数，表达式会在调用时被求值。创建 lambda 函数的句法为 `lambda [parameters]: expression`，lambda 函数可接受任意数量的参数，但只能有一个表达式。使用lambda表达式可以返回一个函数，或者传递一个参数，如下：

```python
>>> x = lambda a, b : a * b	# 利用lambda构造函数x，其中a,b为参数，a*b为表达式
print(x(5, 6))
30

# 使用lambda表达式来返回一个函数
>>> def Power(n):
>>>     return lambda x: x**n
>>> square = Power(2)	# 利用前面定义的函数Power，给n传递2构造新的平方函数square
>>> cube = Power(3)		# 同上，令n=3，这时，cube = lambda x: x**3，输入x，得到x的立方
>>> print('3的平方= %d, 3的立方= %d' % (square(3), cube(3)))
3的平方= 9, 3的立方= 27

# 传递一个小函数作为参数
>>> A = [[1, 'b'], (2, 'd'), [3, 'a'], (4, 'c')]	# 关键是要搞清楚代码执行顺序
>>> A.sort(key=lambda x: x[1])	# 对列表A中四个元素排序，key返回值是参数的第二个元素
>>> A	# 所以得到是按照字母进行的排序
[(3, 'a'), (1, 'b'), (4, 'c'), (2, 'd')]
```

python里面常常使用lambda 来创建匿名函数。所谓匿名，即：不再使用 def 语句这样标准的形式定义一个函数。lambda函数每次只返回一个值，但是如果其表达式设置的巧妙，可以实现很多功能。



### 3.5 map()函数

常和列表搭等配使用的`map()`是一个 Python 内建函数，它允许你不需要使用循环就可以编写简洁的代码。`map()` 会返回一个将 *function* 应用于 *iterable* 中每一项并输出其结果的迭代器。语法为：`map(function, iterable, ...)`，返回一个新的序列对象。

```python
>>> squares = list(map(lambda x: x**2, range(10)))

>>> def multiply(x, y):
>>>     return x ** y
>>> a = [1, 4, 2]
>>> b = [2, 3, 5]
>>> ans = map(Pow, a, b)	# a,b不同维的部分不会被计算
>>> print(list(ans))
[1, 64, 32]
# 等同于:(在定义的函数比较简单时，可以直接用lambda函数)
>>> ans = map(lambda x,y: x**y, a, b)
>>> print(list(ans))
```



### 3.6 列表的其他使用：栈、队列

列表作为堆栈：“后进先出”。添加一个元素到堆栈的顶端，使用 `append()` 。要从堆栈顶部取出一个元素，使用 `pop()` ，不用指定索引。这两个前面讲过，这里不做介绍。

列表作为队列：“先进先出”。列表用作这个目的相当低效。因为在列表的末尾添加和弹出元素非常快，但是在列表的开头插入或弹出元素却很慢 (因为所有的其他元素都必须移动一位)。若要实现一个队列，可使用 collections.deque，它被设计成可以快速地从两端添加或弹出元素。例如：

```python
>>> from collections import deque
>>> queue = deque(["A", "B", "C"])
>>> queue.append("D")	# 对列表的尾部添加元素，相当于堆栈的顶端
>>> queue.append("E")
>>> queue.popleft()		# 先进先出，语句.popleft()是从左侧删除并返回当前值
'A'
>>> queue.popleft()		# 随后是B
'B'
>>> queue				# 剩下的按到达顺序排列
deque(['C', 'D', 'E'])
```



