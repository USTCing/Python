# 元组() 和 字典{}



## 1. 元组 ()：tuple

从前面的内容可以发现，列表和字符串有很多共同特性，例如索引和切片操作。因为他们都是 ***序列*** 数据类型，但他们都是可变的，而同为序列类型的元组，是不可变的 [immutable](https://docs.python.org/zh-cn/3.8/glossary.html#term-immutable)，即元素一旦确定，就不可修改。

### 1.1 创建元组

一个元组由几个被逗号隔开的值组成，输入时圆括号可有可无，不过经常会是必须的（如果这个元组是一个更大的表达式的一部分），例如：

```python
t = 12345, 'hello!'		# 元组内的元素必须是已经确定类型的数据，不可以是未定义的变量
t[0] = 54321			# 元组不可被修改，这里会报错
t = 54321, 'Hi!'		# 但可以被重新定义整个元组
t = (12345, ab, 'hello!')	# 也可以使用圆括号创建元组，但ab没有提前定义，这里会报错

a=[1,2,3]				# 当想修改元组内的元素时，确保该元素本身是可变的
t = (123, a, 'Haha')	# t[1]指向a这个对象，t[1][1]=a[1]
t[1][::]=[3,2,1]		# 元组t依然不变，依然包含三个元素，但a的值发生了变化，可以用t[1]进行比对
```

相比于列表，元组是更简单的数据结构。如果需要存储的一组值在程序的整个生命周期内都不变，可使用元组。  但在使用的过程中一定要注意，列表使用方括号[]标识，而元组是圆括号()，接下来的字典是花括号{}，请务必区分牢记。

### 1.2 特殊元祖及拆包

构造包含0个或1个元素的元组：为了适应这种情况，语法有一些额外的改变。空元组可以直接被一对空圆括号创建，含有一个元素的元组可以通过在这个元素后添加一个逗号来构建。

```python
a = (1,)	# 不加逗号是int型，会跟数学中的括号混淆，3*(-1),-1会被认为是整数，而不是元组
b = ()		# 空元组，size=0
c = 'hello',	# 后面添加逗号，变成元组
# 元组的打包和拆包
t = 1,2,3
a,b,c = t	# a=1,b=2,c=3，变量数量必须和元组长度一致
```

## 2. 集合 {}： set

集合是由**不重复**元素组成的无序的集。它的基本用法包括成员检测和**消除重复元素**。集合对象也支持像：联合，交集，差集，对称差分等数学运算。

### 2.1 集合的创建及修改

可以用花括号或 [set()](https://docs.python.org/zh-cn/3.8/library/stdtypes.html#set) 函数来创建集合。注意：要创建一个空集合你只能用 `set()` 而不能用 `{}`，因为后者是创建一个空字典。集合也支持推导式形式，如：

```python
>>> a={1,2,2,2,3}
>>> a
{1, 2, 3}
>>> a = {x for x in 'abracadabra' if x not in 'abc'}
>>> a
{'r', 'd'}
>>> a.add(2)
>>> a.update([11, 12])
>>> a
{11, 12, 2, 'd', 'r'}
>>> a.discard(2)
>>> a.remove(11)
>>> a
{12, 'd', 'r'}
>>> a.pop()
12
```

### 2.1 集合的运算

集合的交叉并补

```python
# 集合的交集、并集、差集、对称差运算
print(set1 & set2)		# print(set1.intersection(set2))
print(set1 | set2)		# print(set1.union(set2))
print(set1 - set2)		# print(set1.difference(set2))
print(set1 ^ set2)		# print(set1.symmetric_difference(set2))，等于并集-交集
# 判断子集和超集
print(set2 <= set1)		# print(set2.issubset(set1))
print(set1 >= set2)		# print(set1.issuperset(set2))
```



## 3. 字典 {}：dict



dict全称dictionary，使用 **键 - 值**（`key`:`value`）存储，**具有极快的查找速度**。dict是映射类型的数据，不是序列类型的数据，所以其内部存放的顺序和key放入的顺序是没有关系的。举个例子，假设要根据同学的名字查找对应的成绩，如果用list实现，需要两个list：

```python
names = ['Michael', 'Bob', 'Tracy']
scores = [95, 75, 85]
# 使用字典：
d = {'Michael': 95, 'Bob': 75, 'Tracy': 85}
```

给定一个名字，要查找对应的成绩，就需要先在names中按顺序逐一进行匹配找到对应的位置，再从scores取出对应的成绩，list越长，耗时越长。而dict只需要一个“名字”-“成绩”的对照表，通过索引`key`得到对应的值`value`，直接根据名字查找成绩，无论这个表有多大，查找速度都**不会变慢**。

字典主要的操作是使用关键字存储和解析值，因此键必须是唯一的（在一个字典中），一个`key`只能对应一个`value`，所以，多次对一个`key`放入`value`，后面的值会把前面的值覆盖掉。如果索引的`key`不存在，dict就会报错。

字典的值可以是数字、字符串、列表乃至字典。事实上，可将任何Python对象用作字典中的值。

### 3.1 字典的创建和成员判断：

```python
# 直接创建
>>> d = {'Michael': 95, 'Bob': 75, 'Tracy': 85}
# dict() 函数：键值对序列
>>> dict([('A', 10), ('B', 20), ('C', 30)])
{'A': 10, 'B': 20, 'C': 30}
# 字典推导式：从任意的键值表达式中创建字典
>>> {x: x**2 for x in (2, 4, 6)}
{2: 4, 4: 16, 6: 36}
# 通过关键字参数来指定键值对
>>> dict(A=1, B=2, C=3)
{'A': 1, 'B': 2, 'C': 3}
```

### 3.2 字典的操作

字典的操作都是通过对键key的操作执行的，

```python
>>> d = {'Michael': 95, 'Bob': 75, 'Tracy': 85}

>>> d['Tom'] = 99	# 添加元素
>>> d
{'Michael': 95, 'Bob': 75, 'Tracy': 85, 'Tom': 99}
>>> del d['Bob']	# 删除元素
>>> d
 {'Michael': 95, 'Tracy': 85, 'Tom': 99}
>>> d['Tom'] = 100	# 修改元素
>>> d
{'Michael': 95, 'Tracy': 85, 'Tom': 100}
```

在Python的学习中，你经常会发现这种情况，很多语句一看就会，很多例子扫一眼就懂，但在自己用的时候却会经常出错，仔细想想，你真的掌握了吗？

#### in，get()

可以通过`in`判断元素是否在字典的键（key）中，但`in`不会检索元素是否在字典的值（value）中。也可以通过`get(key, default=None)`方法获得对应的键值。如果`key`不存在，默认返回`None`，也可以自己指定返回的内容。


```python
>>> d = {'A': 1, 'B': 2, 'C': 3}
>>> 'D' in d		# 判断键值为'tom'的元素是否在字典d中
False
>>> 3 in d			# in只检索键值，会把3视作键（d的键包括：'A','B','C'）
False
>>> d.get(3,'没有')	# get()函数只会获取键值，不会获取元素，并返回指定信息
'没有'

# 一些注意事项：Python只会返回已定义的变量，未定义的变量都不会返回，即使看起来像字符串也不行
>>> Tom in d    # 这个时候，Tom是一个变量，所有不加引号（''或""）的中英文都会被视为变量
NameError: name 'Tom' is not defined	# 返回的错误信息提示此变量未被定义。
    
>>> 啊啊 = 123	# 好奇心试了下，Spyder下可以用汉字定义变量
>>> d.get('Tom', 啊啊)	# 'Tom'不在字典d中，返回啊啊的值123
123
```

### 3.3 字典的键

与以**连续整数**为索引的序列不同，字典是以 **关键字** 为索引的，关键字可以是任意**不可变**类型，通常是字符串或数字。如果一个元组只包含字符串、数字或元组，那么这个元组也可以用作关键字。但如果元组直接或间接地包含了可变对象，那么它就不能用作关键字。列表不能用作关键字，因为列表可以通过索引、切片或 append() 和 extend() 之类的方法来改变。

对一个字典执行 `list(d)` 将返回包含该字典中所有**键**的列表，按**插入次序**排列 ，当使用 `sorted(d)`排序，默认按照字母或数字对其进行升序排序。

```python
# 回顾上面对字典的操作，以及list(dict)和sort(dict)
>>> del d['A']		# 一定要注意，用的是方括号[]，圆括号()一般用于给函数传入参数
>>> d
{'B': 2, 'C': 3}
>>> d['A']=4
{'B': 2, 'C': 3, 'A': 4}
>>> list(d)
['B', 'C', 'A']
>>> sorted(d)		# 注意是sorted，不是sort
['A', 'B', 'C']
>>> d['a','1'] = 5,6	# 字典不能像int那样交叉赋值
>>> d				# 可以看出，上面的输入被当成了元组，t = 'a','1',type(t)=tuple
{'B': 2, 'C': 3, 'A': 4, ('a', '1'): (5, 6)}
>>> del d[('a', '1')]	# 删除的方法相同
# 下面试试数字及字母大小写的排序规则
d= {'B': 2, 'C': 3, 'A': 4, 'a': 5, '1': 6, 'AO': 7, '@': 8}
>>> sorted(d)
['1', '@', 'A', 'AO', 'B', 'C', 'a']
```

更多排序参考：[排序指南](https://docs.python.org/zh-cn/3.8/howto/sorting.html#sorting-how-to)

### 3.4 字典中循环的技巧

当在字典中循环时，用 `items()` 方法可将关键字和对应的值同时取出：

```python
>>> d = {'A': 1, 'B': 2, 'C': 3}
>>> for x,y in d.items():
>>> 	print(x,y,end=';\t')
A 1;	B 2;	C 3;	
# 指定获取键或值，默认是获取字典的键
>>> for i in d.keys(): print(i, end=' ')	# .keys()可省略
A B C 
>>> for i in d.values(): print(i, end=' ')
1 2 3 
```

用 `enumerate()` 函数可以将**键**和键创建的顺序同时取出，当对字典进行重复的删除和对已删除键进行重建后，想要获取排序，可以使用该命令。

```python
>>> for x,y in enumerate(d):
>>>     print(x,y,end=';\t')
0 A;	1 B;	2 C;	
```

### 3.5 嵌套

因为任何Python对象都可用作字典中的值，可以把一系列字典存储在列表中，或将列表作为值存储在字典中，这称为嵌套。你可以在列表中嵌套字典、在字典中嵌套列表，甚至在字典中嵌套字典。  



